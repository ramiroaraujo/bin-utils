#!/usr/bin/env python3

import sys
import json
import subprocess
from datetime import datetime, timedelta
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor


def choose_project_id():
    options = [
        "ff-app-prod",
        "ff-app-dev",
        "ff-app-iso-1",
        "ff-app-iso-2",
        "ff-app-iso-3",
        "ff-app-iso-4"
    ]
    print("Choose a Project ID:")
    for i, option in enumerate(options):
        print(f"{i + 1}. {option}")

    while True:
        choice = input("Enter the number corresponding to your choice: ").strip()
        if choice.isdigit() and 1 <= int(choice) <= len(options):
            return options[int(choice) - 1]


def build_gcloud_command(conditions, project_id):
    query = " AND ".join(conditions)
    if not any("timestamp" in cond for cond in conditions):
        last_hour_timestamp = (datetime.utcnow() - timedelta(hours=1)).strftime("%Y-%m-%dT%H:%M:%S.%fZ")
        query += f' AND timestamp>="{last_hour_timestamp}"'

    formatted_query = query.replace(" AND ", "\nAND ")
    return [
        'gcloud', 'logging', 'read', query,
        '--format=json',
        '--project=' + project_id
    ]


def run_gcloud_command(command):
    result = subprocess.run(command, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"Error: {result.stderr}")
        sys.exit(1)

    return json.loads(result.stdout)


def fetch_debug_log(log, project_id):
    try:
        timestamp = log['timestamp']
        path = urlparse(log['httpRequest']['requestUrl']).path
        query = (
            f'resource.labels.service_name="job-board-application-api" AND '
            f'labels.path="{path}" AND '
            f'severity="DEBUG" AND '
            f'timestamp>="{timestamp}"'
        )
        command = [
            'gcloud', 'logging', 'read', query,
            '--order=asc',
            '--limit=1',
            '--format=json',
            '--project=' + project_id
        ]
        result = subprocess.run(command, capture_output=True, text=True)
        loaded_json = json.loads(result.stdout)
        if not loaded_json:
            print(f"No debug logs found for timestamp: {timestamp}, path: {path}")
            return None
        debug_log = loaded_json[0]
        if debug_log:
            return {
                "status": log['httpRequest']['status'],
                "payload": debug_log.get('jsonPayload', {}).get('body', '')
            }
        return None
    except Exception as e:
        print(f"Error fetching debug log for timestamp: {timestamp}, path: {path}")
        print(f"Exception: {e}")
        return None


def main():
    project_id = choose_project_id()
    conditions = []
    print("Enter conditions (empty line to finish):")
    while True:
        line = input()
        if line == '':
            if not conditions:
                print("At least one condition must be entered. Exiting.")
                sys.exit(1)
            break
        conditions.append(line.strip())

    final_command = build_gcloud_command(conditions, project_id)
    query_formatted = final_command[3].replace(" AND ", " AND\n").replace(" OR ", " OR\n")
    options_formatted = " \\\n".join(final_command[4:])
    formatted_final_command = f"gcloud logging read '{query_formatted}' \\\n{options_formatted}"
    print(f"Final gcloud command:\n{formatted_final_command}")
    confirm = input("Do you want to proceed? (yes/no): ").strip().lower()

    if confirm != "yes":
        print("Exiting.")
        sys.exit(0)

    logs = run_gcloud_command(final_command)
    if len(logs) > 20:
        print("Warning: More than 20 records were returned.")
        confirm = input("Do you want to proceed? (yes/no): ").strip().lower()
        if confirm != "yes":
            print("Exiting.")
            sys.exit(0)

    with ThreadPoolExecutor() as executor:
        results = list(executor.map(lambda log: fetch_debug_log(log, project_id), logs))

    final_output = [result for result in results if result is not None]
    print(json.dumps(final_output, indent=4))


if __name__ == '__main__':
    main()
