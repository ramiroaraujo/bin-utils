#!/usr/bin/env python3
import subprocess
import argparse
import os
import datetime
import tempfile

# Check for git repository
try:
    subprocess.run(["git", "rev-parse", "--is-inside-work-tree"], check=True, stdout=subprocess.PIPE,
                   stderr=subprocess.PIPE)
except subprocess.CalledProcessError:
    print("Not a git repository. Exiting.")
    exit(1)

# Parse arguments
parser = argparse.ArgumentParser(description="Change git commit dates.")
parser.add_argument('--count', type=int, required=True, help='Number of log entries to fetch.')
args = parser.parse_args()

# Create a dictionary to map short hash to full hash
hash_map = {}

# Fetch N last git log entries using the updated command
log_entries = subprocess.run(
    ["git", "log", f"--pretty=format:%H*#%an*#%ae*#%at*#%s", f"-n{args.count}"],
    stdout=subprocess.PIPE,
    text=True
).stdout.split("\n")

# Format for the editor
editor_content = f"# This string contains the commit hashes and dates for the last {args.count} commits.\n"
editor_content += "# You can edit the dates on each line. When you save and close this file, the commit dates will be updated.\n"

for entry in log_entries:
    parts = entry.split("*#")
    commit_hash = parts[0]
    hash_map[commit_hash[:7]] = commit_hash  # Map short hash to full hash
    timestamp = parts[3]
    date = datetime.datetime.fromtimestamp(int(timestamp)).strftime("%a %b %d %H:%M:%S %Y %z")
    commit_msg = parts[4]
    editor_content += f"{commit_hash[:7]} - {date} - {commit_msg}\n"

# Open in default editor
editor = os.environ.get("EDITOR", "vim")

# Create a temporary file
with tempfile.NamedTemporaryFile(mode='w+', delete=False) as tmpfile:
    tmpfile.write(editor_content)

# Open in default editor
os.system(f"{editor} {tmpfile.name}")

# Read the edited content back
with open(tmpfile.name, 'r') as f:
    edited_content = f.read()

# Remove the temporary file
os.remove(tmpfile.name)

# Initialize the git filter-branch command text
filter_branch_script = 'git filter-branch --env-filter \\\n'

# Parse the edited content
for line in edited_content.strip().split("\n"):
    if not line.startswith("#"):
        parts = line.split(" - ")
        commit_hash_full = hash_map.get(parts[0], parts[0])  # Map back to full hash
        potentially_modified_date = parts[1].strip()
        # Convert the potentially modified date to a Unix timestamp
        dt_obj = datetime.datetime.strptime(potentially_modified_date, "%a %b %d %H:%M:%S %Y")
        timestamp = int(dt_obj.timestamp())

        # Append the conditions and exports for this commit to the filter-branch script
        filter_branch_script += f"if test \"$GIT_COMMIT\" = \"{commit_hash_full}\"; then\n"
        filter_branch_script += f"    export GIT_AUTHOR_DATE=\"{timestamp}\"\n"
        filter_branch_script += f"    export GIT_COMMITTER_DATE=\"{timestamp}\"\n"
        filter_branch_script += "elif "

# Remove the trailing 'elif '
filter_branch_script = filter_branch_script[:-5]

# Append the closing part and cleanup command
earliest_commit = log_entries[-1].split("*#")[0]  # Assuming log_entries are in reverse order
filter_branch_script += f"{earliest_commit}^..HEAD && rm -fr \"$(git rev-parse --git-dir)/refs/original/\""

# Print the generated git filter-branch command
print(filter_branch_script)
